# NixOS module for Alerta monitoring system
#
# This module provides a declarative and modular way to configure Alerta,
# consistent with other services in this homelab configuration. It includes
# support for:
# - ZFS persistence
# - PostgreSQL database integration (via modules.services.postgresql.databases)
# - Caddy reverse proxy with authentication
# - Native OIDC authentication (Alerta has built-in OIDC support)
# - SOPS for secret management
# - Preseed/DR capability
#
# Alerta is an alert consolidation and deduplication system that works alongside
# Alertmanager to provide a unified view of all alerts across your infrastructure.
#
{ config, lib, pkgs, ... }:

let
  cfg = config.modules.services.alerta;

  # Service name used consistently for user/group and dataset paths
  serviceName = "alerta";

  # Alerta Web UI - use the package from pkgs overlay
  # Version tracking via nvfetcher in pkgs/nvfetcher.toml
  alertaWebui = pkgs.alerta-webui;

  # Generate config.json for the webui
  webuiConfig = pkgs.writeText "alerta-webui-config.json" (builtins.toJSON {
    endpoint = "https://${cfg.reverseProxy.hostName or "alerta.${config.networking.domain}"}/api";
    provider = if (cfg.oidc != null && cfg.oidc.enable) then "openid" else "basic";
  });

  # Import shared type definitions
  sharedTypes = import ../../../lib/types.nix { inherit lib; };

  # Import storage helpers for preseed service generation
  storageHelpers = import ../../storage/helpers-lib.nix { inherit pkgs lib; };

  # Define storage configuration for consistent access
  storageCfg = config.modules.storage;

  # Construct the dataset path for alerta
  datasetPath = "${storageCfg.datasets.parentDataset}/alerta";

  # Helper to find replication config from dataset hierarchy
  findReplication = dsPath:
    let
      sanoidDatasets = config.modules.backup.sanoid.datasets;
      replicationInfo = (sanoidDatasets.${dsPath} or { }).replication or null;
    in
    if replicationInfo != null then
      {
        sourcePath = dsPath;
        replication = replicationInfo;
      }
    else
      let
        parts = lib.splitString "/" dsPath;
        parentPath = lib.concatStringsSep "/" (lib.init parts);
      in
      if parentPath == "" || parts == [ ] then
        null
      else
        findReplication parentPath;

  foundReplication = findReplication datasetPath;

  # Compute replication config for preseed service
  replicationConfig =
    if foundReplication == null || !(config.modules.backup.sanoid.enable or false) then
      null
    else
      let
        datasetSuffix =
          if foundReplication.sourcePath == datasetPath then
            ""
          else
            lib.removePrefix "${foundReplication.sourcePath}/" datasetPath;
      in
      {
        targetHost = foundReplication.replication.targetHost;
        targetDataset =
          if datasetSuffix == "" then
            foundReplication.replication.targetDataset
          else
            "${foundReplication.replication.targetDataset}/${datasetSuffix}";
        sshUser = foundReplication.replication.targetUser or config.modules.backup.sanoid.replicationUser;
        sshKeyPath = config.modules.backup.sanoid.sshKeyPath or "/var/lib/zfs-replication/.ssh/id_ed25519";
        sendOptions = foundReplication.replication.sendOptions or "w";
        recvOptions = foundReplication.replication.recvOptions or "u";
      };

  # Build database URL from components
  buildDatabaseUrl =
    { host ? "localhost"
    , port ? 5432
    , name ? serviceName
    , user ? serviceName
    ,
    }: "postgresql://${user}@${host}:${toString port}/${name}";
in
{
  ###### Options

  options.modules.services.alerta = {
    enable = lib.mkEnableOption "Alerta monitoring system";

    package = lib.mkOption {
      type = lib.types.package;
      default = pkgs.alerta-server;
      description = "The alerta-server package to use";
    };

    port = lib.mkOption {
      type = lib.types.port;
      default = 5000;
      description = "Port for Alerta to listen on";
    };

    listenAddress = lib.mkOption {
      type = lib.types.str;
      default = "127.0.0.1";
      description = "Address for Alerta to listen on";
    };

    dataDir = lib.mkOption {
      type = lib.types.path;
      default = "/var/lib/alerta";
      description = "Directory to store Alerta's logs and state";
    };

    environmentFile = lib.mkOption {
      type = lib.types.nullOr lib.types.path;
      default = null;
      description = ''
        Path to environment file containing secrets (PGPASSWORD, OAUTH2_CLIENT_SECRET, etc.)
        This is typically generated by SOPS templates.
      '';
    };

    corsOrigins = lib.mkOption {
      type = lib.types.listOf lib.types.str;
      default = [ ];
      example = [ "https://alerta.example.com" ];
      description = "List of URLs that can access the API for CORS";
    };

    # Database configuration
    database = {
      host = lib.mkOption {
        type = lib.types.str;
        default = "localhost";
        description = "PostgreSQL host";
      };

      port = lib.mkOption {
        type = lib.types.port;
        default = 5432;
        description = "PostgreSQL port";
      };

      name = lib.mkOption {
        type = lib.types.str;
        default = serviceName;
        description = "Database name";
      };

      user = lib.mkOption {
        type = lib.types.str;
        default = serviceName;
        description = "Database user";
      };

      passwordFile = lib.mkOption {
        type = lib.types.nullOr lib.types.path;
        default = null;
        description = "Path to file containing database password";
      };
    };

    # OIDC configuration
    oidc = lib.mkOption {
      type = lib.types.nullOr (lib.types.submodule {
        options = {
          enable = lib.mkEnableOption "OIDC authentication";

          issuerUrl = lib.mkOption {
            type = lib.types.str;
            example = "https://auth.example.com";
            description = "OIDC issuer URL (base URL of identity provider)";
          };

          clientId = lib.mkOption {
            type = lib.types.str;
            example = "alerta";
            description = "OIDC client ID";
          };

          clientSecretFile = lib.mkOption {
            type = lib.types.nullOr lib.types.path;
            default = null;
            description = "Path to file containing OIDC client secret. If null, secret must be provided via environmentFile as OAUTH2_CLIENT_SECRET.";
          };

          authUrl = lib.mkOption {
            type = lib.types.str;
            example = "https://auth.example.com/authorize";
            description = "OIDC authorization endpoint URL";
          };

          tokenUrl = lib.mkOption {
            type = lib.types.str;
            example = "https://auth.example.com/token";
            description = "OIDC token endpoint URL";
          };

          userinfoUrl = lib.mkOption {
            type = lib.types.str;
            example = "https://auth.example.com/userinfo";
            description = "OIDC userinfo endpoint URL";
          };

          logoutUrl = lib.mkOption {
            type = lib.types.str;
            default = "";
            example = "https://auth.example.com/logout";
            description = "OIDC logout endpoint URL";
          };
        };
      });
      default = null;
      description = "OIDC authentication configuration for native SSO support";
    };

    # Alertmanager integration
    alertmanager = {
      apiUrl = lib.mkOption {
        type = lib.types.str;
        default = "http://127.0.0.1:9093";
        description = "URL of the Alertmanager API for status synchronization";
      };
    };

    # Admin user configuration
    adminUsers = lib.mkOption {
      type = lib.types.listOf lib.types.str;
      default = [ ];
      example = [ "admin@example.com" "ops@example.com" ];
      description = ''
        List of user emails that always have admin privileges.
        These users are granted admin access regardless of their OIDC roles.
      '';
    };

    adminRoles = lib.mkOption {
      type = lib.types.listOf lib.types.str;
      default = [ "admin" ];
      example = [ "admin" "ops" "devops" ];
      description = ''
        List of OIDC roles that map to admin privileges in Alerta.
        Users with any of these roles in their OIDC token will be granted admin access.
      '';
    };

    extraConfig = lib.mkOption {
      type = lib.types.lines;
      default = "";
      description = "Additional configuration lines to add to alertad.conf";
    };

    # Standardized reverse proxy integration
    reverseProxy = lib.mkOption {
      type = lib.types.nullOr sharedTypes.reverseProxySubmodule;
      default = null;
      description = "Reverse proxy configuration for Alerta web interface";
    };

    # Standardized metrics collection pattern
    metrics = lib.mkOption {
      type = lib.types.nullOr sharedTypes.metricsSubmodule;
      default = {
        enable = true;
        port = 5000;
        path = "/management/metrics";
        labels = {
          service_type = "monitoring";
          exporter = "alerta";
          function = "alert-consolidation";
        };
      };
      description = "Prometheus metrics collection configuration for Alerta";
    };

    # Standardized logging integration
    logging = lib.mkOption {
      type = lib.types.nullOr sharedTypes.loggingSubmodule;
      default = {
        enable = true;
        journalUnit = "alerta.service";
        labels = {
          service = "alerta";
          service_type = "monitoring";
        };
      };
      description = "Log shipping configuration for Alerta logs";
    };

    # Standardized notifications
    notifications = lib.mkOption {
      type = lib.types.nullOr sharedTypes.notificationSubmodule;
      default = {
        enable = true;
        channels = {
          onFailure = [ "monitoring-alerts" ];
        };
        customMessages = {
          failure = "Alerta monitoring system failed on ${config.networking.hostName}";
        };
      };
      description = "Notification configuration for Alerta service events";
    };

    # Standardized backup configuration
    backup = lib.mkOption {
      type = lib.types.nullOr sharedTypes.backupSubmodule;
      default = null;
      description = "Backup configuration for Alerta data";
    };

    # Preseed/disaster recovery configuration
    preseed = lib.mkOption {
      type = lib.types.nullOr (lib.types.submodule {
        options = {
          enable = lib.mkEnableOption "automatic restore before service start";

          repositoryUrl = lib.mkOption {
            type = lib.types.str;
            description = "URL to restic repository for fallback restore";
          };

          passwordFile = lib.mkOption {
            type = lib.types.path;
            description = "Path to restic repository password file";
          };

          environmentFile = lib.mkOption {
            type = lib.types.nullOr lib.types.path;
            default = null;
            description = "Optional path to environment file for restic (e.g., for cloud storage credentials)";
          };

          restoreMethods = lib.mkOption {
            type = lib.types.listOf (lib.types.enum [ "syncoid" "local" "restic" ]);
            default = [ "syncoid" "local" ];
            description = "Ordered list of restore methods to attempt";
          };
        };
      });
      default = null;
      description = "Disaster recovery preseed configuration";
    };
  };

  ###### Implementation

  config = lib.mkIf cfg.enable (lib.mkMerge [
    {
      # Assertions
      assertions = [
        {
          # Either passwordFile OR environmentFile must be set for PostgreSQL authentication
          assertion = cfg.database.passwordFile != null || cfg.environmentFile != null;
          message = "modules.services.alerta: Either database.passwordFile or environmentFile must be set for PostgreSQL authentication";
        }
        {
          # Either clientSecretFile OR environmentFile must be set when OIDC is enabled
          assertion = cfg.oidc == null || !cfg.oidc.enable || cfg.oidc.clientSecretFile != null || cfg.environmentFile != null;
          message = "modules.services.alerta: Either oidc.clientSecretFile or environmentFile must be set when OIDC is enabled";
        }
      ];

      # Configure native NixOS alerta service
      services.alerta = {
        enable = true;
        port = cfg.port;
        bind = cfg.listenAddress;
        # Database connection via databaseUrl (includes user, host, port, dbname)
        # Password is passed via PGPASSWORD environment variable
        databaseUrl = buildDatabaseUrl {
          host = cfg.database.host;
          port = cfg.database.port;
          name = cfg.database.name;
          user = cfg.database.user;
        };
        databaseName = cfg.database.name;
        corsOrigins = cfg.corsOrigins;
        authenticationRequired = true;
        signupEnabled = false;
        # Additional config including OIDC settings
        extraConfig = ''
          ${lib.optionalString (cfg.oidc != null && cfg.oidc.enable) ''
          AUTH_PROVIDER = 'openid'
          OIDC_ISSUER_URL = '${cfg.oidc.issuerUrl}'
          OIDC_AUTH_URL = '${cfg.oidc.authUrl}'
          OIDC_TOKEN_URL = '${cfg.oidc.tokenUrl}'
          OIDC_USERINFO_URL = '${cfg.oidc.userinfoUrl}'
          OAUTH2_CLIENT_ID = '${cfg.oidc.clientId}'
          OIDC_LOGOUT_URL = '${cfg.oidc.logoutUrl}'
          ''}

          # Admin user and role configuration
          ADMIN_USERS = [${lib.concatMapStringsSep ", " (u: "'${u}'") cfg.adminUsers}]
          ADMIN_ROLES = [${lib.concatMapStringsSep ", " (r: "'${r}'") cfg.adminRoles}]

          # Alertmanager integration
          ALERTMANAGER_API_URL = '${cfg.alertmanager.apiUrl}'

          ${cfg.extraConfig}
        '';
      };

      # Override the upstream systemd service to add our customizations
      systemd.services.alerta = {
        # Wait for PostgreSQL and ZFS before starting
        after = [ "network.target" "postgresql.service" "zfs-mount.service" ]
          ++ lib.optional (cfg.preseed != null && cfg.preseed.enable) "preseed-alerta.service";
        requires = [ "postgresql.service" ];
        wants = lib.optional (cfg.preseed != null && cfg.preseed.enable) "preseed-alerta.service";

        serviceConfig = {
          # Use static user instead of dynamic for SOPS secret access
          DynamicUser = lib.mkForce false;
          User = lib.mkForce serviceName;
          Group = lib.mkForce serviceName;

          # State directory management
          StateDirectory = serviceName;
          StateDirectoryMode = "0750";

          # Security hardening
          ProtectSystem = "strict";
          ProtectHome = true;
          PrivateTmp = true;
          NoNewPrivileges = true;
          ReadWritePaths = [ cfg.dataDir "/var/lib/alerta" ];

          # Load environment from SOPS template file
          EnvironmentFile = lib.mkIf (cfg.environmentFile != null) cfg.environmentFile;
        };
      };

      # Ensure user has a group set (native module doesn't set group by default)
      users.users.${serviceName} = {
        group = serviceName;
      };
      users.groups.${serviceName} = { };

      # ZFS dataset for Alerta data
      modules.storage.datasets.services.${serviceName} = {
        mountpoint = cfg.dataDir;
        recordsize = "16K"; # Small files (logs, state)
        compression = "lz4";
        owner = serviceName;
        group = serviceName;
        mode = "0750";
        properties = {
          atime = "off";
          "com.sun:auto-snapshot" = "true";
        };
      };

      # Alerta requires a custom Caddy configuration because it serves:
      # 1. Static web UI files at /
      # 2. API proxy at /api/*
      # 3. SPA fallback for client-side routing
      #
      # We use handleOnly mode which skips generating a reverse_proxy directive,
      # allowing our handle blocks to control all routing.
      modules.services.caddy.virtualHosts.${serviceName} = lib.mkIf (cfg.reverseProxy != null && cfg.reverseProxy.enable) {
        enable = true;
        hostName = cfg.reverseProxy.hostName;

        # Handle-only mode: no reverse_proxy generated, we control routing via handle blocks
        handleOnly = true;

        extraConfig = ''
          # Override config.json with generated version containing API endpoint
          # Use rewrite to serve the file correctly (handle_path strips the path)
          handle /config.json {
            rewrite * /config.json
            root * ${pkgs.runCommand "alerta-webui-config" {} ''mkdir -p $out && cp ${webuiConfig} $out/config.json''}
            file_server
          }

          # Proxy API requests to alerta-server
          # Use handle_path to strip /api prefix since Alerta's API routes are at root
          handle_path /api/* {
            reverse_proxy 127.0.0.1:${toString cfg.port}
          }

          # Proxy management/metrics endpoint
          handle /management/* {
            reverse_proxy 127.0.0.1:${toString cfg.port}
          }

          # Serve static webui files with SPA fallback
          # Package installs to share/alerta-webui/
          handle {
            root * ${alertaWebui}/share/alerta-webui
            try_files {path} /index.html
            file_server
          }
        '';
      };

      # Add alerta CLI to system packages for administrative use
      environment.systemPackages = [ pkgs.alerta ];
    }

    # Preseed service for disaster recovery (merged as separate config fragment)
    (lib.mkIf (cfg.preseed != null && cfg.preseed.enable)
      (storageHelpers.mkPreseedService {
        inherit serviceName;
        dataset = datasetPath;
        mountpoint = cfg.dataDir;
        mainServiceUnit = "alerta.service";
        replicationCfg = replicationConfig;
        datasetProperties = {
          recordsize = "16K";
          compression = "lz4";
          "com.sun:auto-snapshot" = "true";
        };
        resticRepoUrl = cfg.preseed.repositoryUrl;
        resticPasswordFile = cfg.preseed.passwordFile;
        resticEnvironmentFile = cfg.preseed.environmentFile;
        resticPaths = [ cfg.dataDir ];
        restoreMethods = cfg.preseed.restoreMethods;
        hasCentralizedNotifications = config.modules.notifications.enable or false;
        owner = serviceName;
        group = serviceName;
      }))
  ]);
}
