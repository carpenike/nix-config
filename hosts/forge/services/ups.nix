# UPS Monitoring Configuration
#
# Monitors APC Smart-UPS 2200 RM XL via SNMP for graceful shutdown on low battery.
# Exports metrics to Prometheus via node_exporter textfile collector.
# PeaNUT provides a web dashboard and API for Homepage widget integration.
#
# Infrastructure Contributions:
#   - Backup: Not applicable (hardware monitor, no persistent data)
#   - Sanoid: Not applicable (no ZFS dataset)
#   - Monitoring: UPS-specific alerts defined below (battery, load, status)
#   - Homepage: PeaNUT widget for UPS status display
{ config, pkgs, lib, mylib, ... }:
let
  serviceEnabled = config.power.ups.enable or false;
  peanutPort = 8089; # Port for PeaNUT web dashboard
in
{
  # UPS system control (graceful shutdown on low battery)
  # Using Network UPS Tools (NUT) to monitor APC Smart-UPS 2200 RM XL at 10.9.18.245
  #
  # NixOS 25.05 uses power.ups module (not services.nut)
  # APC Network Management Cards use SNMP, not NUT server (upsd)
  # This uses standalone mode with snmp-ups driver to monitor via SNMP
  #
  # Prometheus metrics are exported via node_exporter textfile collector every 15 seconds
  # Security: Runs as node-exporter user (same pattern as pgbackrest metrics) with systemd hardening
  # Security: SNMP community string and upsmon passwords managed via sops-nix

  power.ups = {
    enable = true;
    mode = "standalone";

    # Define the UPS - using snmp-ups driver for APC network management card
    ups.apc = {
      driver = "snmp-ups";
      port = "10.9.18.245"; # IP address of the APC network management card
      description = "APC Smart-UPS 2200 RM XL";

      # SNMP driver configuration for APC
      # Note: Not specifying mibs directive - let NUT auto-detect the correct MIB
      # Community string placeholder - replaced at runtime by ups-inject-secrets service
      directives = [
        "community = @SNMP_COMMUNITY@"
      ];
    };

    # Monitor the local UPS (upsd runs locally in standalone mode)
    upsmon.monitor.apc = {
      system = "apc@localhost";
      powerValue = 1;
      user = "upsmon";
      passwordFile = config.sops.secrets."ups/upsmon-password".path;
      type = "primary"; # This system initiates shutdown (formerly "master")
    };

    # Define the upsmon user for local upsd access
    users.upsmon = {
      passwordFile = config.sops.secrets."ups/upsmon-password".path;
      upsmon = "primary"; # Primary monitoring role (formerly "master")
      # Allow this user to set variables and trigger forced shutdown
      actions = [ "set" "fsd" ];
      instcmds = [ "all" ];
    };
  };

  # Install NUT client utilities for manual UPS querying
  # Use: upsc apc@localhost to check UPS status
  environment.systemPackages = [ pkgs.nut ];

  # Inject SNMP community string from sops-nix secret into NUT configuration
  # This service runs before the UPS driver starts and replaces the placeholder
  systemd.services.ups-inject-secrets = lib.mkIf serviceEnabled {
    description = "Inject UPS SNMP community string from sops-nix";
    wantedBy = [ "nut-driver-apc.service" ];
    before = [ "nut-driver-apc.service" ];
    after = [ "network-online.target" ];
    wants = [ "network-online.target" ];
    serviceConfig = {
      Type = "oneshot";
      RemainAfterExit = true;
    };
    script = ''
      # Read the SNMP community string from sops secret
      SNMP_COMMUNITY=$(${pkgs.coreutils}/bin/cat ${config.sops.secrets."ups/snmp-community".path})

      # Replace placeholder in NUT ups.conf with actual community string
      # The configuration file is generated by NixOS at /etc/nut/ups.conf
      ${pkgs.gnused}/bin/sed -i "s|@SNMP_COMMUNITY@|$SNMP_COMMUNITY|g" /etc/nut/ups.conf
    '';
  };

  # Add network dependency to UPS driver service and require secrets injection
  # The UPS is accessed via SNMP over the network at 10.9.18.245
  # Without this, the service can start before network is available, causing failures
  systemd.services.upsdrv = {
    after = [ "network-online.target" ] ++ lib.optional serviceEnabled "ups-inject-secrets.service";
    wants = [ "network-online.target" ];
    requires = lib.optionals serviceEnabled [ "ups-inject-secrets.service" ];
  };

  # Export UPS metrics to Prometheus via node_exporter textfile collector
  # Metrics are written to /var/lib/node_exporter/textfile_collector/ups.prom
  # and automatically scraped by the existing node_exporter service
  systemd.timers.ups-metrics = {
    wantedBy = [ "timers.target" ];
    timerConfig = {
      OnBootSec = "1m"; # Start 1 minute after boot
      OnUnitActiveSec = "15s"; # Run every 15 seconds
      Unit = "ups-metrics.service";
    };
  };

  systemd.services.ups-metrics = {
    description = "Export UPS metrics to Prometheus textfile collector";
    after = [ "upsd.service" "upsmon.service" "prometheus-node-exporter.service" ];
    wants = [ "prometheus-node-exporter.service" ];

    serviceConfig = {
      Type = "oneshot";
      # Run as node-exporter user to write to textfile directory
      # Follows same pattern as pgbackrest metrics in default.nix
      User = "node-exporter";
      # upsc queries upsd over TCP/localhost and doesn't require special group membership
      # Systemd hardening
      ProtectSystem = "strict";
      ProtectHome = true;
      PrivateTmp = true;
      NoNewPrivileges = true;
      # Allow writing to the textfile directory
      ReadWritePaths = [ "/var/lib/node_exporter/textfile_collector" ];
    };

    script = ''
      # Capture timestamp and check if upsc succeeds
      TIMESTAMP=$(${pkgs.coreutils}/bin/date +%s)
      TEMP_DATA=$(${pkgs.coreutils}/bin/mktemp)

      # Query UPS status and check exit code
      if ${pkgs.nut}/bin/upsc apc@localhost > "$TEMP_DATA" 2>/dev/null; then
        SCRAPE_SUCCESS=1
      else
        SCRAPE_SUCCESS=0
      fi

      # Process UPS data and convert to Prometheus format
      ${pkgs.coreutils}/bin/cat "$TEMP_DATA" | ${pkgs.gawk}/bin/awk '
        BEGIN {
          OFS = ""
          # Initialize status flags to 0
          on_battery = 0
          low_battery = 0
          online = 0
        }

        # Battery metrics
        /^battery\.charge:/ {
          if ($2 ~ /^[0-9.]+$/) print "ups_battery_charge{ups=\"apc\"} ", $2
        }
        /^battery\.runtime:/ {
          if ($2 ~ /^[0-9.]+$/) print "ups_battery_runtime_seconds{ups=\"apc\"} ", $2
        }
        /^battery\.voltage:/ {
          if ($2 ~ /^[0-9.]+$/) print "ups_battery_voltage{ups=\"apc\"} ", $2
        }

        # Load and power metrics
        /^ups\.load:/ {
          if ($2 ~ /^[0-9.]+$/) print "ups_load_percent{ups=\"apc\"} ", $2
        }
        /^ups\.realpower\.nominal:/ {
          if ($2 ~ /^[0-9.]+$/) print "ups_realpower_nominal_watts{ups=\"apc\"} ", $2
        }

        # Voltage metrics
        /^input\.voltage:/ {
          if ($2 ~ /^[0-9.]+$/) print "ups_input_voltage{ups=\"apc\"} ", $2
        }
        /^output\.voltage:/ {
          if ($2 ~ /^[0-9.]+$/) print "ups_output_voltage{ups=\"apc\"} ", $2
        }

        # Temperature
        /^ups\.temperature:/ {
          if ($2 ~ /^[0-9.]+$/) print "ups_temperature_celsius{ups=\"apc\"} ", $2
        }

        # UPS status flags - parse the entire status string (can be multi-token like "OB LB")
        /^ups\.status:/ {
          # Extract everything after the colon to capture full status string
          idx = index($0, ":")
          status = substr($0, idx+2)
          # OB = On Battery, LB = Low Battery, OL = Online
          if (status ~ /OB/) on_battery = 1
          if (status ~ /LB/) low_battery = 1
          if (status ~ /OL/) online = 1
        }

        END {
          # Output status flags
          print "ups_on_battery{ups=\"apc\"} ", on_battery
          print "ups_low_battery{ups=\"apc\"} ", low_battery
          print "ups_online{ups=\"apc\"} ", online
        }
      ' > /var/lib/node_exporter/textfile_collector/ups.prom.tmp

      # Add scrape metadata metrics
      echo "ups_metrics_scrape_success{ups=\"apc\"} $SCRAPE_SUCCESS" >> /var/lib/node_exporter/textfile_collector/ups.prom.tmp
      echo "ups_metrics_last_scrape_timestamp_seconds{ups=\"apc\"} $TIMESTAMP" >> /var/lib/node_exporter/textfile_collector/ups.prom.tmp

      # Clean up temp file
      ${pkgs.coreutils}/bin/rm -f "$TEMP_DATA"

      # Atomic move to prevent partial reads
      ${pkgs.coreutils}/bin/mv /var/lib/node_exporter/textfile_collector/ups.prom.tmp \
                               /var/lib/node_exporter/textfile_collector/ups.prom

      # Set appropriate permissions (644 allows node_exporter to read)
      ${pkgs.coreutils}/bin/chmod 644 /var/lib/node_exporter/textfile_collector/ups.prom
    '';
  };

  # Alert rules for UPS monitoring
  # Using monitoring-helpers library for consistency where patterns fit
  modules.alerting.rules = lib.mkIf serviceEnabled {
    # Metrics scraping failure - using threshold helper
    "ups-metrics-scrape-failed" = mylib.monitoring-helpers.mkThresholdAlert {
      name = "ups";
      alertname = "UPSMetricsScrapeFailure";
      expr = "ups_metrics_scrape_success == 0";
      for = "5m";
      severity = "high";
      category = "monitoring";
      summary = "UPS metrics collection failed on {{ $labels.instance }}";
      description = "Unable to scrape UPS metrics from NUT. Check ups-metrics.service and upsd.service logs.";
    };

    # UPS-specific alerts - these have unique descriptions/context that don't fit generic helpers
    # Keeping them as custom alerts for clarity and UPS-specific language
    "ups-on-battery" = {
      type = "promql";
      alertname = "UPSOnBattery";
      expr = "ups_on_battery == 1";
      for = "2m";
      severity = "medium";
      labels = { service = "ups"; category = "power"; };
      annotations = {
        summary = "UPS {{ $labels.ups }} running on battery power";
        description = "Power outage detected. Current battery: {{ with query \"ups_battery_charge{ups='apc'}\" }}{{ . | first | value }}{{ end }}%, runtime: {{ with query \"ups_battery_runtime_seconds{ups='apc'}\" }}{{ . | first | value | humanizeDuration }}{{ end }}";
      };
    };

    # Low battery warning - Runtime calibration completed (October 2025)
    "ups-low-battery" = {
      type = "promql";
      alertname = "UPSLowBattery";
      expr = "ups_low_battery == 1";
      for = "0s"; # Immediate alert
      severity = "critical";
      labels = { service = "ups"; category = "power"; };
      annotations = {
        summary = "UPS {{ $labels.ups }} battery critically low";
        description = "UPS low battery flag set. System shutdown imminent. Battery: {{ with query \"ups_battery_charge{ups='apc'}\" }}{{ . | first | value }}{{ end }}%, runtime: {{ with query \"ups_battery_runtime_seconds{ups='apc'}\" }}{{ . | first | value | humanizeDuration }}{{ end }}";
      };
    };

    # Battery charge threshold using capacity helper
    "ups-battery-charge-low" = mylib.monitoring-helpers.mkHighCapacityAlert {
      name = "ups";
      expr = "ups_battery_charge < 50";
      for = "5m";
      severity = "medium";
      category = "power";
      summary = "UPS {{ $labels.ups }} battery charge below 50%";
      description = "Battery charge at {{ $value }}%. Runtime remaining: {{ with query \"ups_battery_runtime_seconds{ups='apc'}\" }}{{ . | first | value | humanizeDuration }}{{ end }}";
    };

    # Runtime critically low (less than 5 minutes)
    "ups-runtime-critical" = {
      type = "promql";
      alertname = "UPSRuntimeCritical";
      expr = "ups_battery_runtime_seconds < 300";
      for = "1m";
      severity = "critical";
      labels = { service = "ups"; category = "power"; };
      annotations = {
        summary = "UPS {{ $labels.ups }} runtime critically low";
        description = "Only {{ $value | humanizeDuration }} of battery runtime remaining. Prepare for shutdown.";
      };
    };

    # High load warning using threshold helper
    "ups-load-high" = mylib.monitoring-helpers.mkThresholdAlert {
      name = "ups";
      alertname = "UPSLoadHigh";
      expr = "ups_load_percent > 80";
      for = "10m";
      severity = "medium";
      category = "capacity";
      summary = "UPS {{ $labels.ups }} load is high";
      description = "Current load: {{ $value }}%. Consider load balancing or UPS upgrade if sustained.";
    };

    # Temperature warning using threshold helper
    "ups-temperature-high" = mylib.monitoring-helpers.mkThresholdAlert {
      name = "ups";
      alertname = "UPSTemperatureHigh";
      expr = "ups_temperature_celsius > 30";
      for = "15m";
      severity = "medium";
      category = "health";
      summary = "UPS {{ $labels.ups }} temperature elevated";
      description = "UPS temperature at {{ $value }}Â°C. Check ventilation and ambient temperature.";
    };

    # UPS offline using threshold helper
    "ups-offline" = mylib.monitoring-helpers.mkThresholdAlert {
      name = "ups";
      alertname = "UPSOffline";
      expr = "ups_online == 0";
      for = "2m";
      severity = "critical";
      category = "connectivity";
      summary = "UPS {{ $labels.ups }} appears offline";
      description = "Cannot communicate with UPS or UPS reports offline status. Check network connectivity and UPS health.";
    };
  };

  # PeaNUT container for Homepage widget integration
  # Provides a web dashboard and API endpoint for NUT UPS monitoring
  # Configuration is done through the UI and stored in /var/lib/peanut/settings.yml
  virtualisation.oci-containers.containers.peanut = lib.mkIf serviceEnabled {
    image = "docker.io/brandawg93/peanut:5.21.2@sha256:b613c7e1421911c928ed7b10ad16888a56c9d8eb9c51c43c4452d3ab8ea08c22";
    autoStart = true;

    environment = {
      TZ = "America/New_York";
      WEB_HOST = "0.0.0.0";
      WEB_PORT = toString peanutPort;
      # NUT_HOST and NUT_PORT are configured via the web UI
    };

    # Config persistence
    volumes = [
      "/var/lib/peanut:/config:rw"
    ];

    # Only expose on localhost - accessed via reverse proxy or directly
    ports = [
      "127.0.0.1:${toString peanutPort}:${toString peanutPort}"
    ];

    # Use host network to access NUT on localhost:3493
    extraOptions = [
      "--network=host"
      # Resource limits based on Prometheus data:
      # - 7d max: 73 MB, current: ~100 MB
      # - Limit: 256M (2.5x headroom), Reservation: 128M
      "--memory=256m"
      "--memory-reservation=128m"
      "--cpus=0.5"
      # Image has built-in healthcheck using exec form (no shell needed)
      # as of commit b5fe006 (Jan 2026): CMD ["node", "healthcheck.mjs"]
    ];
  };

  # Create data directory and pre-configure PeaNUT to connect to local NUT server
  systemd.tmpfiles.rules = lib.mkIf serviceEnabled [
    "d /var/lib/peanut 0755 root root -"
  ];

  # Pre-configure PeaNUT to connect to the local NUT server
  # This runs before the container starts and sets up the NUT server connection
  # Password placeholder will be replaced by peanut-config service at runtime
  environment.etc."peanut-settings.yml" = lib.mkIf serviceEnabled {
    text = ''
      NUT_SERVERS:
        - HOST: localhost
          PORT: 3493
          USERNAME: upsmon
          PASSWORD: @UPSMON_PASSWORD@
      INFLUX_HOST: ""
      INFLUX_TOKEN: ""
      INFLUX_ORG: ""
      INFLUX_BUCKET: ""
      INFLUX_INTERVAL: 10
      DATE_FORMAT: MM/DD/YYYY
      TIME_FORMAT: 12-hour
      DASHBOARD_SECTIONS:
        - key: KPIS
          enabled: true
        - key: CHARTS
          enabled: true
        - key: VARIABLES
          enabled: true
      DISABLE_VERSION_CHECK: false
      TEMPERATURE_UNIT: celsius
    '';
  };

  # Copy config to PeaNUT data directory and inject secrets before container starts
  systemd.services.peanut-config = lib.mkIf serviceEnabled {
    description = "Configure PeaNUT settings with secrets";
    wantedBy = [ "podman-peanut.service" ];
    before = [ "podman-peanut.service" ];
    serviceConfig = {
      Type = "oneshot";
      RemainAfterExit = true;
    };
    script = ''
      # Read the upsmon password from sops secret
      UPSMON_PASSWORD=$(${pkgs.coreutils}/bin/cat ${config.sops.secrets."ups/upsmon-password".path})

      # Create PeaNUT directory and copy template config
      ${pkgs.coreutils}/bin/mkdir -p /var/lib/peanut
      ${pkgs.coreutils}/bin/cp /etc/peanut-settings.yml /var/lib/peanut/settings.yml

      # Replace placeholder with actual password
      ${pkgs.gnused}/bin/sed -i "s|@UPSMON_PASSWORD@|$UPSMON_PASSWORD|g" /var/lib/peanut/settings.yml

      # Set appropriate permissions
      ${pkgs.coreutils}/bin/chmod 644 /var/lib/peanut/settings.yml
    '';
  };

  # Homepage contribution for UPS monitoring via PeaNUT
  modules.services.homepage.contributions.ups = lib.mkIf serviceEnabled {
    group = "Infrastructure";
    name = "UPS";
    icon = "apc";
    href = "http://forge.holthome.net:${toString peanutPort}";
    description = "APC Smart-UPS 2200 RM XL";
    widget = {
      type = "peanut";
      url = "http://127.0.0.1:${toString peanutPort}";
      key = "apc"; # UPS name in NUT
    };
  };

  # Gatus endpoint for PeaNUT web UI availability (external/user-perspective check)
  modules.services.gatus.contributions.peanut = lib.mkIf serviceEnabled {
    name = "PeaNUT";
    group = "Infrastructure";
    url = "http://127.0.0.1:${toString peanutPort}/api/ping";
    interval = "60s";
    conditions = [
      "[STATUS] == 200"
    ];
  };
}
