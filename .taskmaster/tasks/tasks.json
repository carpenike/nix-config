{
  "master": {
    "tasks": [
      {
        "id": 26,
        "title": "Establish Flake Structure and System Builders",
        "description": "Create the foundational Nix flake structure with system builders for both NixOS and Darwin platforms",
        "details": "1. Create a `flake.nix` file at the root of the repository that defines inputs (nixpkgs, home-manager, darwin, etc.)\n2. Implement `lib/mkSystem.nix` with functions to build configurations for both NixOS and Darwin\n3. Set up a basic directory structure:\n   - hosts/: For host-specific configurations\n   - hosts/_modules/: For shared modules (common, nixos, darwin)\n   - home/: For Home Manager configurations\n   - overlays/: For package modifications\n   - pkgs/: For custom packages\n4. Create a simple argument passing system for dependency injection between modules\n5. Implement basic validation to catch configuration errors\n6. Ensure the flake builds successfully with `nix flake check`",
        "testStrategy": "1. Verify flake evaluation with `nix flake check`\n2. Test building a minimal NixOS configuration\n3. Test building a minimal Darwin configuration\n4. Validate directory structure follows the planned architecture\n5. Ensure proper error messages are displayed for common configuration mistakes",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 27,
        "title": "Implement Modular Configuration System",
        "description": "Create a layered module system with clear separation of concerns between common, platform-specific, and host-specific configurations",
        "details": "1. Design a module structure with three layers:\n   - Common modules (shared across all systems)\n   - Platform-specific modules (NixOS vs Darwin)\n   - Host-specific configurations\n2. Create standard module interfaces with options and config attributes\n3. Implement module composition logic in `lib/mkSystem.nix`\n4. Set up inheritance patterns for configuration values\n5. Create helper functions for common configuration patterns\n6. Implement conditional module loading based on system type\n7. Document the module system architecture and usage patterns",
        "testStrategy": "1. Create test modules for each layer and verify proper inheritance\n2. Test platform-specific module loading on different system types\n3. Verify that common configurations are properly applied across platforms\n4. Test module composition with conflicting configurations to ensure proper resolution\n5. Validate that helper functions produce expected configuration outputs",
        "priority": "high",
        "dependencies": [
          26
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 28,
        "title": "Set Up SOPS-based Secrets Management",
        "description": "Implement secure secrets management using SOPS with age keys for encrypted configuration across hosts",
        "details": "1. Set up SOPS integration with the Nix flake\n2. Generate age keys for each host and store public keys in the repository\n3. Create a `.sops.yaml` configuration file defining access policies\n4. Implement a secrets directory structure under `hosts/<hostname>/secrets/`\n5. Create templates for common secret types (credentials, certificates, etc.)\n6. Write helper functions for secret deployment and usage\n7. Document secret rotation and management procedures\n8. Implement integration with the module system for automatic secret deployment",
        "testStrategy": "1. Test encryption and decryption of sample secrets\n2. Verify that secrets are only accessible by the intended hosts\n3. Test secret rotation procedure on a non-critical system\n4. Validate that secrets are properly deployed to the correct locations\n5. Ensure secrets are not exposed in the Nix store or logs",
        "priority": "high",
        "dependencies": [
          26,
          27
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 29,
        "title": "Configure Home Manager Integration",
        "description": "Set up Home Manager for consistent user environments across all platforms with shared configurations",
        "details": "1. Create a base Home Manager configuration in `home/default.nix`\n2. Implement platform-specific Home Manager modules (Darwin vs NixOS)\n3. Set up user profiles with shared development tools and configurations\n4. Configure shell environments (zsh, bash) with consistent aliases and functions\n5. Set up dotfiles management through Home Manager\n6. Implement editor configurations (VSCode, Neovim) with consistent theming\n7. Create language-specific development environments (Python, Node.js, Go)\n8. Integrate Home Manager with the system builders in `lib/mkSystem.nix`",
        "testStrategy": "1. Test Home Manager configuration on both NixOS and Darwin platforms\n2. Verify that user environments are consistent across different hosts\n3. Test shell configuration and aliases on different platforms\n4. Validate that editor configurations are properly applied\n5. Test language-specific development environments with sample projects",
        "priority": "medium",
        "dependencies": [
          26,
          27
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 30,
        "title": "Implement Core Infrastructure Services",
        "description": "Configure essential home lab services including DNS, reverse proxy, and container orchestration",
        "status": "done",
        "dependencies": [
          26,
          27,
          28
        ],
        "priority": "medium",
        "details": "1. Create NixOS modules for DNS services:\n   - AdGuard Home configuration\n   - Blocky for DNS filtering\n   - BIND for authoritative DNS\n   - DNSdist for load balancing\n2. Implement reverse proxy configurations:\n   - Caddy with automatic HTTPS\n   - HAProxy for load balancing\n   - Nginx for static content\n3. Set up Podman-based container orchestration:\n   - Network configuration\n   - Volume management\n   - Container definitions\n   - Enhanced podmanLib with mkHealthCheck helper and resource limit support\n   - Configurable UID/GID for all containerized services\n4. Configure basic monitoring with Glances and Node Exporter:\n   - Secure Glances configuration (localhost binding only)\n   - Reverse proxy integration with hostname-based routing\n   - Systemd hardening and resource limits\n   - Flexible configuration with extraArgs\n5. Implement network management for Unifi and Omada controllers:\n   - Unifi Controller with 1GB memory, 1 CPU limits\n   - Omada Controller with 512MB memory, 0.75 CPU limits\n6. Create service dependency management to ensure proper startup order\n7. Implement 1Password Connect with 128MB memory, 0.25 CPU limits",
        "testStrategy": "1. Test DNS resolution with each configured DNS service\n2. Verify reverse proxy configurations with test services\n3. Test container deployment and networking\n4. Validate monitoring data collection and security (especially for Glances)\n5. Test service dependencies during system startup\n6. Verify network management functionality\n7. Validate resource limits on containerized services\n8. Test UID/GID configuration for containers",
        "subtasks": [
          {
            "id": 1,
            "title": "Enhance podmanLib with resource management features",
            "description": "Implement mkHealthCheck helper and resource limit support in podmanLib",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Update Omada Controller with resource limits",
            "description": "Configure Omada Controller with 512MB memory, 0.75 CPU limits and configurable UID/GID",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Update Unifi Controller with resource limits",
            "description": "Configure Unifi Controller with 1GB memory, 1 CPU limits and configurable UID/GID",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Update 1Password Connect with resource limits",
            "description": "Configure 1Password Connect (both API and sync containers) with 128MB memory, 0.25 CPU limits",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Implement configurable user/group ownership for containers",
            "description": "Make all containerized services have configurable user/group ownership instead of hardcoded 999",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Improve Glances system monitoring security",
            "description": "Fix network exposure (bind to localhost only), add reverse proxy integration, remove insecure openFirewall option, add systemd hardening and resource limits, and make configuration flexible with extraArgs",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Implement DNS services",
            "description": "Create NixOS modules for AdGuard Home, Blocky, BIND, and DNSdist",
            "status": "done",
            "dependencies": [],
            "details": "Successfully implemented all DNS services:\n- AdGuard Home for primary DNS filtering\n- Blocky as secondary DNS filtering option\n- BIND for authoritative DNS\n- DNSdist for load balancing",
            "testStrategy": "Verified DNS resolution with each configured service and confirmed proper functionality"
          },
          {
            "id": 8,
            "title": "Configure reverse proxy services",
            "description": "Implement Caddy, HAProxy, and Nginx configurations",
            "status": "done",
            "dependencies": [],
            "details": "Completed implementation of all reverse proxy services:\n- Caddy with automatic HTTPS for web services\n- HAProxy for load balancing\n- Nginx for static content\n- Configured hostname-based routing for all services",
            "testStrategy": "Tested all reverse proxy configurations with various services and verified proper routing and HTTPS functionality"
          },
          {
            "id": 9,
            "title": "Set up Node Exporter monitoring",
            "description": "Configure Node Exporter for system metrics collection",
            "status": "done",
            "dependencies": [],
            "details": "Implemented Node Exporter for system metrics collection with proper security hardening",
            "testStrategy": "Verified metrics collection and confirmed secure configuration"
          },
          {
            "id": 10,
            "title": "Implement service dependency management",
            "description": "Create proper startup order for all infrastructure services",
            "status": "done",
            "dependencies": [],
            "details": "Established proper service dependencies to ensure correct startup order for all infrastructure services",
            "testStrategy": "Tested system startup sequence and verified services start in the correct order"
          },
          {
            "id": 11,
            "title": "Configure Glances on luna with authentication",
            "description": "Enable Glances on luna host with proper authentication via SOPS secrets",
            "status": "done",
            "dependencies": [
              6
            ],
            "details": "Configured Glances on luna with authentication using SOPS for secure secret management",
            "testStrategy": "Verified authentication works properly and secrets are securely managed"
          },
          {
            "id": 12,
            "title": "Update nixpi with secure Glances configuration",
            "description": "Apply the improved secure Glances configuration to nixpi host",
            "status": "done",
            "dependencies": [
              6
            ],
            "details": "Updated nixpi to use the secure Glances configuration with all security improvements",
            "testStrategy": "Confirmed nixpi is using the secure configuration with proper localhost binding and reverse proxy integration"
          }
        ]
      },
      {
        "id": 31,
        "title": "Configure Development Environment Toolchain",
        "description": "Set up comprehensive development tools including language support, Kubernetes tools, and editor configurations",
        "details": "1. Configure language-specific development environments:\n   - Python with virtual environments and common packages\n   - Node.js with npm/yarn and development tools\n   - Go with proper GOPATH configuration\n2. Set up Kubernetes toolchain:\n   - kubectl with autocompletion\n   - Custom kubectl plugins for workflow enhancement\n   - Helm for package management\n   - k9s for cluster management\n3. Configure infrastructure-as-code tools:\n   - Terraform with provider configurations\n   - Ansible for configuration management\n4. Implement editor configurations:\n   - VSCode with extensions and settings\n   - Neovim with plugins and keybindings\n5. Set up consistent theming across all development tools",
        "testStrategy": "1. Test each language environment with sample projects\n2. Verify Kubernetes tools against a test cluster\n3. Test infrastructure-as-code tools with sample configurations\n4. Validate editor configurations and extensions\n5. Test consistent theming across different applications",
        "priority": "medium",
        "dependencies": [
          26,
          27,
          29
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 32,
        "title": "Create Host-Specific Configurations",
        "description": "Implement specific configurations for each target host (rymac, luna, rydev, nixos-bootstrap, nixpi)",
        "details": "1. Create host directories under `hosts/` for each target system:\n   - rymac (Darwin): Primary development machine\n   - luna (NixOS x86_64): Production infrastructure services\n   - rydev (NixOS aarch64): Development and testing\n   - nixos-bootstrap: Base system deployment\n   - nixpi: Raspberry Pi configuration\n2. Configure hardware-specific settings for each host\n3. Set up host-specific service configurations\n4. Implement Disko for declarative disk management on NixOS hosts\n5. Create host-specific network configurations\n6. Set up boot configurations appropriate for each platform\n7. Configure host-specific user accounts and permissions",
        "testStrategy": "1. Test building configurations for each host\n2. Verify hardware-specific settings are correctly applied\n3. Test service configurations on appropriate hosts\n4. Validate disk configurations with Disko\n5. Test network configurations for connectivity\n6. Verify boot configurations with test boots where possible",
        "priority": "medium",
        "dependencies": [
          26,
          27,
          28,
          29,
          30
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 33,
        "title": "Set Up Attic Binary Cache for Improved Build Performance",
        "description": "Deploy a self-hosted Attic binary cache server on luna with secure configuration and integrate with all client machines to achieve approximately 10x faster rebuilds.",
        "details": "1. Install and configure Attic server on luna:\n   - Set up the Attic service using the NixOS module\n   - Configure storage backend with appropriate retention policies\n   - Set up authentication and access control mechanisms\n   - Implement TLS with proper certificates (possibly using ACME)\n   - Configure backup strategy for cache data\n\n2. Create cache management infrastructure:\n   - Set up cache signing keys with proper permissions\n   - Configure cache pruning policies to manage disk usage\n   - Implement monitoring for cache size and performance\n   - Create maintenance scripts for cache optimization\n\n3. Configure client-side integration:\n   - Add Attic cache to substituters in Nix configuration\n   - Configure trusted public keys for all clients\n   - Set up appropriate bandwidth and connection limits\n   - Implement fallback to official cache for missing packages\n\n4. Implement automated cache population:\n   - Configure CI/CD pipeline to push built derivations to the cache\n   - Set up post-build hooks to automatically push local builds\n   - Create policies for which derivations should be cached\n\n5. Optimize cache performance:\n   - Configure appropriate compression settings\n   - Tune network parameters for optimal throughput\n   - Implement request rate limiting to prevent overload\n   - Set up caching headers for improved performance\n\n6. Document cache usage and maintenance:\n   - Create documentation for adding new clients\n   - Document troubleshooting procedures\n   - Create guidelines for cache maintenance and monitoring\n   - Document backup and recovery procedures",
        "testStrategy": "1. Verify Attic server deployment:\n   - Confirm service is running and accessible from the network\n   - Test authentication mechanisms\n   - Validate TLS configuration with SSL testing tools\n   - Verify storage backend is properly configured\n\n2. Test cache functionality:\n   - Push test derivations to the cache\n   - Verify derivations can be retrieved from other hosts\n   - Test cache signing and verification\n   - Measure cache hit rates and performance improvements\n\n3. Benchmark performance improvements:\n   - Measure build times before and after cache implementation\n   - Compare performance across different host types\n   - Test concurrent access from multiple clients\n   - Verify bandwidth usage is within expected parameters\n\n4. Validate security configuration:\n   - Ensure only authorized clients can push to the cache\n   - Verify that only properly signed packages are accepted\n   - Test access control mechanisms\n   - Validate that sensitive information is not exposed\n\n5. Test failure scenarios:\n   - Simulate network outages and verify graceful fallback\n   - Test cache server restart procedures\n   - Verify behavior when cache storage is near capacity\n   - Test backup and recovery procedures",
        "status": "pending",
        "dependencies": [
          27,
          28,
          30,
          32
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 34,
        "title": "Implement Backup and Restore Strategy for Stateful NixOS Services",
        "description": "Research and implement comprehensive backup and restore mechanisms for critical NixOS services that maintain state outside the Nix store, with special focus on services using mutableSettings=true like AdGuard Home.",
        "details": "1. Research and document state management patterns in NixOS:\n   - Identify services using mutableSettings=true in the current configuration\n   - Map all critical stateful data locations across deployed services\n   - Document the persistence mechanisms used by each service\n\n2. Design a layered backup strategy:\n   - Create a central backup module in the NixOS configuration\n   - Implement service-specific backup hooks for each stateful service\n   - Configure automated, scheduled backups with retention policies\n   - Set up secure remote storage for backups (possibly using SOPS for credentials)\n\n3. Implement AdGuard Home backup solution:\n   - Create a backup script that preserves AdGuard configuration and statistics\n   - Ensure backup captures both /var/lib/AdGuardHome and runtime configuration\n   - Test backup during service updates to verify completeness\n\n4. Develop restore procedures:\n   - Create documented restore workflows for each service\n   - Implement restore scripts with appropriate permission handling\n   - Test restore procedures in isolation to verify effectiveness\n\n5. Integrate with existing infrastructure:\n   - Configure backup monitoring and alerting\n   - Add backup status to system health checks\n   - Document backup locations and retention policies\n\n6. Implement backup rotation and pruning:\n   - Configure retention policies (daily, weekly, monthly)\n   - Implement secure cleanup of expired backups\n   - Monitor backup storage usage\n\n7. Create disaster recovery documentation:\n   - Step-by-step recovery procedures for each critical service\n   - Required credentials and access methods\n   - Verification steps for successful restoration",
        "testStrategy": "1. Test backup creation:\n   - Verify automated backup execution on schedule\n   - Validate backup content contains all critical configuration\n   - Check backup integrity and completeness\n   - Confirm proper permissions on backup files\n\n2. Test restore procedures:\n   - Perform test restores in isolated environments\n   - Verify service functionality after restore\n   - Measure restore time and document in disaster recovery plan\n   - Test restoration to different host to verify portability\n\n3. Validate AdGuard Home specific backup/restore:\n   - Backup AdGuard Home with active configuration\n   - Modify settings and verify they're captured in subsequent backups\n   - Restore to a previous configuration and verify settings are properly applied\n   - Test migration between AdGuard Home versions\n\n4. Test backup rotation:\n   - Verify old backups are properly pruned according to retention policy\n   - Confirm backup storage doesn't exceed allocated space\n   - Test recovery using backups of different ages\n\n5. Perform disaster recovery simulation:\n   - Simulate complete system failure\n   - Follow documented recovery procedures\n   - Measure time to restore full functionality\n   - Document any gaps or improvements needed",
        "status": "pending",
        "dependencies": [
          27,
          28,
          30,
          32
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 35,
        "title": "Implement ZFS + Restic Backup System with Systemd Orchestration",
        "description": "Create a comprehensive backup system using ZFS snapshots and Restic with systemd orchestration, supporting both local and cloud destinations, with service-specific configurations for critical services.",
        "details": "1. Create the core backup module structure:\n   - Implement `modules/nixos/backup.nix` with the main orchestration logic\n   - Create `lib/backup-helpers.nix` with the `mkResticBackup` function for generating service-specific backup configurations\n   - Define the systemd target chain: pre-backup-tasks.target → zfs-snapshot.service → restic-backup.target → post-backup-tasks.target\n\n2. Implement ZFS snapshot functionality:\n   - Configure daily ZFS snapshots at 2:00 AM for crash-consistent state\n   - Set up snapshot naming conventions and retention policies\n   - Create mount points for snapshots to ensure backups run from snapshots, not live filesystems\n\n3. Configure Restic backup system:\n   - Set up repository initialization and configuration\n   - Implement encryption and compression settings\n   - Configure both local (NAS) and remote (Cloudflare R2/B2) destinations\n   - Set up proper retention policies (daily, weekly, monthly)\n\n4. Create service-specific backup configurations:\n   - UniFi: Pre-snapshot MongoDB dumps with proper authentication\n   - 1Password Connect: Configuration and data directory backups\n   - Attic: Binary cache data backup with consistency checks\n   - Omada: Controller database and configuration backups\n\n5. Implement monitoring and notification system:\n   - Integrate with Healthchecks.io for backup success/failure monitoring\n   - Configure ntfy.sh notifications for backup status alerts\n   - Set up logging with structured output for easier debugging\n\n6. Create documentation and restore procedures:\n   - Document the complete backup architecture\n   - Create step-by-step restore guides for each service\n   - Implement restore helper scripts for common recovery scenarios\n   - Document disaster recovery procedures\n\n7. Implement backup verification:\n   - Add automated integrity checks for backups\n   - Create test restore procedures that validate backup completeness",
        "testStrategy": "1. Test ZFS snapshot creation:\n   - Verify snapshots are created at the scheduled time\n   - Confirm proper naming and retention\n   - Test snapshot mounting functionality\n\n2. Test Restic backup operations:\n   - Verify backups are created from snapshots, not live filesystems\n   - Confirm data is properly stored in both local and remote destinations\n   - Test deduplication by making small changes and verifying incremental backup size\n   - Validate encryption by attempting to access backup data without credentials\n\n3. Test service-specific backup configurations:\n   - Verify pre-backup database dumps for UniFi and Omada\n   - Confirm 1Password Connect data is properly backed up\n   - Test Attic binary cache backup integrity\n\n4. Test monitoring and notifications:\n   - Simulate backup failures to verify Healthchecks.io integration\n   - Confirm ntfy.sh notifications are sent for both success and failure cases\n   - Verify logs contain sufficient information for troubleshooting\n\n5. Test restore procedures:\n   - Perform complete test restores for each critical service\n   - Validate service functionality after restore\n   - Time the restore process to establish recovery time objectives\n   - Test restore from both local and remote backup destinations\n\n6. Test system integration:\n   - Verify systemd target chain executes in the correct order\n   - Confirm dependencies between backup tasks are properly handled\n   - Test backup system behavior during system resource constraints",
        "status": "pending",
        "dependencies": [
          27,
          28,
          30,
          32,
          34
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 36,
        "title": "Refactor Host Configurations into Profile-Based Architecture",
        "description": "Restructure the monolithic host configurations into a profile-based architecture to eliminate approximately 80% of configuration duplication between luna, rydev, and other hosts.",
        "details": "1. Create the new directory structure:\n   - Create `hosts/profiles/hardware/` directory with:\n     - `x86_64-generic.nix` for luna and rydev\n     - `rpi4.nix` for nixpi\n   - Create `hosts/profiles/roles/` directory with:\n     - `server.nix` for SSH, users, and firewall configurations\n     - `container-host.nix` for Podman setup\n     - `reverse-proxy.nix` for Caddy/HAProxy configurations\n     - `dns.nix` for AdGuard/Bind configurations\n\n2. Extract common hardware configurations:\n   - Analyze existing hardware configurations in luna and rydev\n   - Extract common patterns to `profiles/hardware/x86_64-generic.nix`\n   - Ensure hardware-specific settings (CPU, GPU, memory) are properly parameterized\n   - Create specialized hardware profile for Raspberry Pi in `profiles/hardware/rpi4.nix`\n\n3. Implement role-based modules:\n   - Create `server.nix` with core server functionality (SSH, user management, firewall)\n   - Implement `container-host.nix` with Podman/container runtime configurations\n   - Build `reverse-proxy.nix` with Caddy/HAProxy settings and common proxy patterns\n   - Develop `dns.nix` with AdGuard/Bind configurations and DNS management\n\n4. Refactor existing host configurations:\n   - Modify luna configuration to import and compose profiles instead of direct configuration\n   - Update rydev to use the same profile-based approach\n   - Ensure nixpi uses the rpi4 hardware profile\n   - Preserve host-specific customizations while leveraging shared profiles\n\n5. Implement profile composition mechanism:\n   - Create helper functions in `lib/` for combining profiles with host-specific overrides\n   - Ensure profiles can be composed without conflicts\n   - Implement a clean API for importing profiles in host configurations\n\n6. Preserve existing functionality:\n   - Maintain DNS aggregation across hosts\n   - Ensure service integrations continue to work\n   - Verify network configurations remain intact\n   - Keep backup configurations working properly\n\n7. Document the new architecture:\n   - Create README.md in the profiles directory explaining the design\n   - Document each profile's purpose and configuration options\n   - Provide examples of how to compose profiles for new hosts",
        "testStrategy": "1. Test profile imports:\n   - Verify that each profile can be imported individually without errors\n   - Test composition of multiple profiles to ensure they don't conflict\n   - Validate that hardware profiles correctly set up system hardware\n\n2. Test configuration generation:\n   - Build configurations for luna and rydev using the new profile-based approach\n   - Compare the generated configurations with previous versions to ensure equivalence\n   - Verify that approximately 80% of duplicated configuration has been eliminated\n\n3. Test incremental migration:\n   - Apply changes incrementally to one host at a time\n   - Verify each host continues to function correctly after refactoring\n   - Test that service-specific configurations are preserved\n\n4. Validate role-based modules:\n   - Test server.nix by verifying SSH, user, and firewall configurations\n   - Validate container-host.nix by testing Podman functionality\n   - Test reverse-proxy.nix by verifying proxy configurations and routing\n   - Verify dns.nix by testing DNS resolution and filtering\n\n5. Test hardware profiles:\n   - Verify x86_64-generic.nix correctly configures luna and rydev hardware\n   - Test rpi4.nix with nixpi to ensure proper Raspberry Pi configuration\n   - Validate that hardware-specific optimizations are correctly applied\n\n6. Integration testing:\n   - Deploy the refactored configurations to test environments\n   - Verify all services start correctly\n   - Test network connectivity and service availability\n   - Validate that DNS aggregation still works properly",
        "status": "pending",
        "dependencies": [
          26,
          27,
          32
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 37,
        "title": "Implement Comprehensive Security Hardening Based on 2025 NixOS Best Practices",
        "description": "Enhance system security by implementing per-machine SOPS keys, robust firewall configurations, and container security hardening based on 2025 NixOS security best practices.",
        "details": "1. Implement per-machine SOPS keys:\n   - Generate unique age keys per host using ssh-to-age from SSH host keys\n   - Update `.sops.yaml` with host-specific encryption policies\n   - Create host-specific secret directories: `secrets/hosts/{luna,rydev}/`\n   - Re-encrypt all existing secrets with new key policies\n   - Document the new key management approach\n\n2. Configure robust firewall settings:\n   - Re-enable firewall on luna (currently disabled)\n   - Implement deny-by-default policy with declarative port opening\n   - Create a firewall module with service-specific rule definitions\n   - Add IPv6 rules to match IPv4 configurations\n   - Enable firewall logging for security auditing\n   - Configure log rotation for firewall logs\n\n3. Implement container security hardening:\n   - Create a secure-by-default container configuration with:\n     - `--cap-drop=ALL` to remove all capabilities\n     - `--read-only` for read-only filesystem\n     - `--security-opt=no-new-privileges` to prevent privilege escalation\n   - Develop a capability management system for containers that need specific capabilities\n   - Update all existing container services with the new security defaults\n   - Document required capabilities for each service\n\n4. Update documentation:\n   - Document the security hardening measures implemented\n   - Create a security audit checklist\n   - Update the README with security best practices\n   - Document the process for adding new services securely",
        "testStrategy": "1. Test per-machine SOPS keys:\n   - Verify each host can only decrypt its own secrets\n   - Attempt to decrypt a secret on an unauthorized host (should fail)\n   - Test the re-encryption process on a sample secret\n   - Validate that all secrets are properly accessible on their intended hosts\n\n2. Test firewall configuration:\n   - Verify firewall is enabled and running on all hosts\n   - Test connectivity to allowed services from authorized networks\n   - Attempt connections to closed ports (should be rejected)\n   - Verify IPv6 rules are working correctly\n   - Check firewall logs for expected entries\n   - Test each service-specific rule to ensure proper access\n\n3. Test container security hardening:\n   - Verify containers start successfully with the new security defaults\n   - Attempt privilege escalation within containers (should fail)\n   - Test file system modifications in read-only containers (should fail)\n   - Verify services function correctly with minimal capabilities\n   - Run security scanning tools against hardened containers\n   - Document any capability exceptions required for specific services\n\n4. Perform overall security validation:\n   - Run NixOS security scanner to validate configurations\n   - Perform port scanning to verify closed ports\n   - Test system for common vulnerabilities\n   - Verify logging is working for security events",
        "status": "pending",
        "dependencies": [
          27,
          28,
          30,
          32,
          36
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 38,
        "title": "Implement mkPodmanService Helper for Standardized Container Deployment",
        "description": "Create a comprehensive service helper function in lib/service-helpers.nix to standardize container deployment with security defaults, automatic reverse proxy registration, backup integration, and resource management.",
        "details": "1. Create the `lib/service-helpers.nix` file with the following structure:\n   - Implement the core `mkPodmanService` function with the specified signature:\n   ```nix\n   mkPodmanService = {\n     appName, image, volumes?, ports?, envFile?,\n     reverseProxy? = { enable = false; },\n     security? = { readOnlyRoot = true; caps.drop = [\"ALL\"]; },\n     backup? = { enable = false; paths = []; }\n   };\n   ```\n   - Add comprehensive documentation for each parameter and option\n   - Implement sensible defaults for all optional parameters\n\n2. Implement security hardening features:\n   - Configure read-only root filesystem by default\n   - Drop all capabilities by default with selective granting\n   - Implement user namespace mapping for container isolation\n   - Add seccomp profile integration\n   - Configure SELinux/AppArmor integration where applicable\n\n3. Create automatic Caddy reverse proxy registration:\n   - Generate virtualHost configurations based on service parameters\n   - Support both HTTP and HTTPS endpoints\n   - Implement automatic Let's Encrypt certificate provisioning\n   - Configure proper headers for security and caching\n\n4. Integrate with the backup system:\n   - Automatically register backup paths when backup.enable = true\n   - Create pre-backup hooks for database dumps or application-specific preparations\n   - Implement consistent backup naming and organization\n\n5. Add resource management features:\n   - CPU limits and reservations\n   - Memory constraints\n   - I/O prioritization\n   - Network bandwidth controls\n\n6. Implement directory and permission management:\n   - Automatic creation of required directories\n   - Proper permission setting for volumes\n   - UID/GID mapping for container access\n\n7. Refactor existing service definitions to use the new helper:\n   - Convert UniFi controller configuration\n   - Update 1Password service definition\n   - Migrate Omada controller setup\n   - Refactor Glances monitoring service\n\n8. Create comprehensive examples and documentation:\n   - Add detailed comments explaining the implementation\n   - Create example configurations for common use cases\n   - Document best practices for service definition",
        "testStrategy": "1. Unit test the helper function:\n   - Verify that the function generates correct NixOS module output\n   - Test with various parameter combinations to ensure proper defaults\n   - Validate security settings are correctly applied\n   - Check that reverse proxy configurations are properly generated\n\n2. Integration testing with existing services:\n   - Compare the output of refactored services with original configurations\n   - Verify that all functionality is preserved after migration\n   - Test that services start correctly with the new configuration\n   - Validate that reverse proxy settings work as expected\n\n3. Security validation:\n   - Run container security scanning tools on deployed containers\n   - Verify that containers run with minimal privileges\n   - Test that read-only root filesystem is properly enforced\n   - Validate capability restrictions\n\n4. Backup integration testing:\n   - Verify that backup paths are correctly registered\n   - Test backup execution with pre-backup hooks\n   - Validate that backups contain all necessary data\n   - Test restore procedures from generated backups\n\n5. Performance testing:\n   - Measure resource usage with the new configuration\n   - Compare startup times before and after refactoring\n   - Verify that resource limits are properly enforced\n\n6. Documentation validation:\n   - Review documentation for completeness and accuracy\n   - Test examples to ensure they work as documented\n   - Verify that all parameters are properly documented",
        "status": "pending",
        "dependencies": [
          30,
          35,
          36,
          37
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 39,
        "title": "Implement NixOS Operational Safety Warnings and Monitoring System",
        "description": "Create a comprehensive warning and monitoring system for NixOS configurations that alerts on critical misconfigurations and integrates with existing backup and security systems.",
        "details": "1. Implement the core warning system module:\n   - Create `modules/nixos/warnings.nix` to centralize warning definitions\n   - Implement using NixOS `warnings` list in the module system\n   - Define warning categories: security, backup, monitoring, configuration\n   - Add conditional warnings based on system purpose (production vs. development)\n\n2. Implement specific warning checks:\n   - Backup status warnings:\n     ```nix\n     (mkIf (!cfg.backup.enable && config.mySystem.purpose != \"Development\") \n       \"WARNING: Backups are disabled on production host ${config.networking.hostName}!\")\n     ```\n   - Security configuration warnings:\n     ```nix\n     (mkIf (!config.networking.firewall.enable && config.mySystem.purpose != \"Development\")\n       \"WARNING: Firewall is disabled on production host ${config.networking.hostName}!\")\n     (mkIf (config.services.openssh.permitRootLogin != \"no\")\n       \"WARNING: Root SSH login is not explicitly disabled!\")\n     ```\n   - Monitoring service warnings:\n     ```nix\n     (mkIf (!config.services.prometheus.enable && config.mySystem.purpose != \"Development\")\n       \"WARNING: Prometheus monitoring is disabled on production host!\")\n     ```\n   - Service-specific warnings for critical services\n\n3. Integrate with existing backup system:\n   - Add warning checks for backup configuration issues\n   - Implement backup success/failure notifications\n   - Connect with the ZFS + Restic backup system from Task 35\n   - Add backup status to monitoring dashboard\n\n4. Implement monitoring integration:\n   - Create simple status dashboard for operational visibility\n   - Add service health monitoring alerts\n   - Implement Prometheus exporters for custom metrics\n   - Configure alerting rules for critical services\n\n5. Create helper functions in `lib/warning-helpers.nix`:\n   - `mkServiceWarning`: Generate service-specific warnings\n   - `mkSecurityWarning`: Generate security-related warnings\n   - `mkBackupWarning`: Generate backup-related warnings\n\n6. Document the warning system:\n   - Create comprehensive documentation on available warnings\n   - Add examples of extending the warning system\n   - Document integration points with other modules",
        "testStrategy": "1. Test warning generation:\n   - Verify warnings appear during system build when conditions are met\n   - Test each warning condition by deliberately misconfiguring test systems\n   - Confirm warnings are suppressed for development systems as appropriate\n   - Validate that warnings appear in both nixos-rebuild output and system journal\n\n2. Test monitoring integration:\n   - Verify backup success/failure notifications are sent\n   - Test service health monitoring by simulating service failures\n   - Validate dashboard displays correct operational status\n   - Confirm alerts are triggered when warning conditions persist\n\n3. Test integration with existing systems:\n   - Verify warnings correctly detect backup system misconfiguration\n   - Test interaction with security hardening configurations\n   - Confirm warnings detect when critical services are disabled\n   - Validate that profile-based configurations properly inherit warnings\n\n4. Perform system-wide testing:\n   - Build test configurations with various combinations of warnings\n   - Verify warning messages are clear and actionable\n   - Test on both production and development profiles\n   - Confirm no false positives in warning generation",
        "status": "pending",
        "dependencies": [
          27,
          35,
          36,
          37
        ],
        "priority": "low",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-09-30T13:53:55.465Z",
      "updated": "2025-10-02T22:56:43.511Z",
      "description": "Tasks for master context"
    }
  }
}
